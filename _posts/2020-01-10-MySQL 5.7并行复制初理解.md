---
layout:     post
title:      MySQL 5.7并行复制中并行的真正含义
subtitle:   
date:       2020-01-10
author:     BY
header-img: img/home-bg-art.jpg
catalog: true
tags:
    - mysql
---


## MySQL 5.7并行复制初理解

​     我们知道MySQL 5.7并行复制引入了两个值last_committed和sequence_number。last_committed表示事务提交的时候，上次事务提交的编号，在主库上同时提交的事务设置成相同的last_committed。如果事务具有相同的last_committed，表示这些事务都在一组内，可以进行并行的回放。这个机制也是Commit-Parent-Based SchemeWL#6314中的实现方式。不过之后，官方对这种模式做了改进，所以最新的并行回放机制和WL#6314有了不同，详情见**Lock-Based SchemeWL#7165**。

​    下面介绍一下旧模式**Commit-Parent-Based SchemeWL#6314**和新模式Lock-Based SchemeWL#7165的不同之处，以及改进的地方。**Commit-Parent-Based Scheme WL#6314**

Commit-Parent-Based Scheme简介

- 在master上，有一个全局计数器（global counter）。在每一次存储引擎提交之前，计数器值就会增加。

- 在master上，在事务进入prepare阶段之前，全局计数器的当前值会被储存在事务中。这个值称为此事务的commit-parent。

- 在master上，commit-parent会在事务的开头被储存在binlog中。

- 在slave上，如果两个事务有同一个commit-parent，他们就可以并行被执行。 

  此commit-parent就是我们在binlog中看到的last_committed。如果commit-parent相同，即last_committed相同，则被视为同一组，可以并行回放。Commit-Parent-Based Scheme的问题一句话：Commit-Parent-Based Scheme会降低复制的并行程度.

![图片描述](C:\Users\kris\Documents\GitHub\baoleiaabb.github.io\img\20170728093603489)

解释一下图：

- 水平虚线表示事务按时间顺序往后走。
- P表示事务在进入prepare阶段之前读到的commit-parent值的那个时间点。可以简单的视为加锁时间点。
- C表示事务增加了全局计数器（global counter）的值的那个时间点。可以简单的视为释放锁的时间点
- P对应的commit-parent（last_commited）是取自所有已经执行完的事务的最大的C对应的sequence_number。举例来说： 
- Trx4的P对应的commit-parent（last_commited）取自所有已经执行完的事务的最大的C对应的sequence_number，也就是Trx1的C对应的sequence_number。因为这个时候Trx1已经执行完，但是Trx2还未执行完。 
- Trx5的P对应的commit-parent（last_commited）取自所有已经执行完的事务的最大的C对应的sequence_number，也就是Trx2的C对应的sequence_number；Trx6的P对应的commit-parent（last_commited）取自所有已经执行完的事务的最大的C对应的sequence_number，也就是Trx2的C对应的sequence_number。所以Trx5和Trx6具有相同的commit-parent（last_commited），在进行回放的时候，Trx5和Trx6可以并行回放。
- 由图可见，Trx5 和 Trx6可以并发执行，因为他们的commit-parent是相同的，都是由Trx2设定的。但是，Trx4和Trx5不能并发执行, Trx6和Trx7也不能并发执行。我们可以注意到，在同一时段，Trx4和Trx5、Trx6和Trx7分别持有他们各自的锁，事务互不冲突。所以，如果在slave上并发执行，也是不会有问题的。根据以上例子，可以得知：
- Trx4、Trx5和Trx6在同一时间持有各自的锁，但Trx4无法并发执行。
- Trx6和Trx7在同一时间持有各自的锁，但Trx7无法并发执行。
  但是，实际上，Trx4是可以和Trx5、Trx6并行执行，Trx6可以和Trx7并行执行。 如果能实现这个，那么并行复制的效果会更好。所以官方对并行复制的机制做了改进，提出了一种新的并行复制的方式：Lock-Based Scheme。

### Lock-Based Scheme WL#7165

实现：如果两个事务在同一时间持有各自的锁，就可以并发执行。

**Lock-Based Scheme简介**

首先，定义了一个称为lock interval的概念，含义： 一个事务持有锁的时间间隔。

- 当存储引擎提交，第一把锁释放，lock interval结束。
- 当最后一把锁获取，lock interval开始。假定：最后一把锁获取是在binlog_prepare阶段。

假设有两个事务：Trx1、Trx2。Trx1先于Trx2。那么，当且仅当Trx1、Trx2的lock interval有重叠，则可以并行执行。换言之，当且仅当Trx1结束自己的lock interval要早于Trx2开始自己的lock interval，则不能并行执行。

<img src="C:\Users\kris\Documents\GitHub\baoleiaabb.github.io\img\20170728094332059" alt="img"  />

```
  L表示lock interval的开始点  
  C表示lock interval的结束
```

​    对于C（lock interval的结束点），MySQL会给每个事务分配一个逻辑时间戳（logical timestamp），命名为：transaction.sequence_number。此外，MySQL会获取全局变量global.max_committed_transaction，含义：所有已经结束lock interval的事务的最大的sequence_number。

   对于L（lock interval的开始点），MySQL会把global.max_committed_timestamp分配给一个变量，并取名叫transaction.last_committed。

​     transaction.sequence_number和transaction.last_committed这两个时间戳都会存放在binlog中。根据以上分析，我们可以得出在slave上执行事务的条件：

​    如果所有正在执行的事务的最小的sequence_number大于一个事务的transaction.last_committed，那么这个事务就可以并发执行。

   换言之：slave的work线程不能开始执行一个事务，直到这个事务的last_committed值小于所有其他正在执行事务的sequence_number。

根据以上分析，回过头来看前面的那幅图：

![图片描述](C:\Users\kris\Documents\GitHub\baoleiaabb.github.io\img\20170728094621260)



​      可以看到Trx3、Trx4、Trx5、Trx6四个事务可以并发执行。因为Trx3的sequence_number大于Trx4、Trx5、Trx6的last_committed，所以可以并发执行。

​     当Trx3、Trx4、Trx5执行完成之后，Trx6和Trx7可以并发执行。因为Trx6的sequence_number大于Trx7的last_committed，即两者的lock interval存在重叠。

​      Trx5和Trx7不能并发执行，因为：Trx5的sequence_number小于Trx7的last_committed，即两者的lock interval不存在重叠。综上所述，可以有三种方法来判断slave上事务是否可以并行执行：假设有两个事务：Trx1、Trx2。Trx1先于Trx2。那么，当且仅当Trx1、Trx2的lock interval有重叠，则可以并行执行。
​      如果所有正在执行的事务的最小的sequence_number大于一个事务的transaction.last_committed，那么这个事务就可以并发执行。
​       slave 的work线程不能开始执行一个事务，直到这个事务的last_committed值小于所有其他正在执行事务的sequence_number。
由上分析，新模式Lock-Based Scheme机制的并发度比旧模式Commit-Parent-Based Scheme的并发度要好。 